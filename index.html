<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Polygon-only Export ‚Äî 2048√ó1365 (FIX)</title>

    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet.draw -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"
    />
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

    <style>
      html,
      body,
      #map {
        height: 100%;
        margin: 0;
      }
      #map {
        background: #0b0f17;
      }
      .toolbar {
        position: absolute;
        right: 12px;
        top: 12px;
        z-index: 1000;
        background: rgba(11, 15, 23, 0.85);
        color: #e5e7eb;
        border: 1px solid #1f2937;
        border-radius: 14px;
        padding: 12px;
        font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        backdrop-filter: blur(6px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
        display: grid;
        gap: 8px;
        min-width: 300px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .btn {
        border: 1px solid #374151;
        background: #111827;
        color: #e5e7eb;
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }
      .btn:hover {
        background: #0b1220;
      }
      input[type="text"],
      input[type="number"],
      input[type="color"] {
        border: 1px solid #374151;
        background: #0b0f17;
        color: #e5e7eb;
        border-radius: 10px;
        padding: 7px 10px;
      }
      small {
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div class="toolbar" id="ui">
      <div class="row">
        <strong>Basemap:</strong> <code>./base_map.png</code> (2048√ó1365)
      </div>

      <div class="row">
        <label>Stroke</label>
        <input
          id="strokeW"
          type="number"
          value="3"
          min="1"
          max="40"
          style="width: 90px"
        />
        <input id="strokeC" type="color" value="#00e0ff" title="Warna stroke" />
        <label>Fill Œ±</label>
        <input
          id="fillA"
          type="number"
          value="0.25"
          min="0"
          max="1"
          step="0.05"
          style="width: 90px"
        />
        <input id="fillC" type="color" value="#00e0ff" title="Warna fill" />
        <button class="btn" id="applyStyle">Terapkan</button>
      </div>

      <div class="row">
        <button id="fit" class="btn">üîé Zoom ke Gambar</button>
        <button id="clear" class="btn">üßπ Bersihkan</button>
      </div>

      <div class="row">
        <input
          id="filename"
          type="text"
          placeholder="Nama file (opsional)"
          style="flex: 1"
        />
      </div>

      <button id="export" class="btn">‚¨áÔ∏è Ekspor PNG (poligon saja)</button>
      <small
        >Poligon saja (background transparan). Gunakan toolbar Leaflet di kiri
        atas untuk menggambar.</small
      >
    </div>

    <script>
      // --- Konstanta gambar ---
      const IMG_W = 2048,
        IMG_H = 1365,
        IMG_PATH = "./base_map.png";

      // --- Peta (CRS.Simple: lat = -y, lng = x) ---
      const map = L.map("map", {
        crs: L.CRS.Simple,
        preferCanvas: true,
        zoomControl: true,
        minZoom: -5,
        zoomSnap: 0.5,
        zoomDelta: 0.5,
        wheelDebounceTime: 40,
        wheelPxPerZoomLevel: 96,
      });

      // Pakai bounds terbalik di sumbu Y
      const bounds = [
        [0, 0],
        [-IMG_H, IMG_W],
      ];
      L.imageOverlay(IMG_PATH, bounds, { interactive: false }).addTo(map);
      map.setMaxBounds(bounds);
      map.fitBounds(bounds, { animate: false });

      // --- Gambar & kontrol ---
      const drawnItems = new L.FeatureGroup().addTo(map);

      let style = {
        color: "#00e0ff",
        weight: 3,
        fillOpacity: 0.25,
        fillColor: "#00e0ff",
      };
      let drawControl = buildDraw(style);
      map.addControl(drawControl);
      map.on(L.Draw.Event.CREATED, (e) => drawnItems.addLayer(e.layer));

      function buildDraw(shapeOptions) {
        return new L.Control.Draw({
          position: "topleft",
          draw: {
            polygon: { allowIntersection: false, showArea: true, shapeOptions },
            rectangle: { shapeOptions },
            polyline: false,
            circle: false,
            circlemarker: false,
            marker: false,
          },
          edit: { featureGroup: drawnItems, remove: true },
        });
      }

      // --- UI ---
      document.getElementById("fit").onclick = () => map.fitBounds(bounds);
      document.getElementById("clear").onclick = () => {
        if (confirm("Hapus semua poligon?")) drawnItems.clearLayers();
      };
      document.getElementById("applyStyle").onclick = () => {
        const strokeW = clamp(
          parseFloat(document.getElementById("strokeW").value) || 3,
          1,
          40
        );
        const fillA = clamp(
          parseFloat(document.getElementById("fillA").value) || 0.25,
          0,
          1
        );
        const strokeC = document.querySelector("#strokeC").value || "#00e0ff";
        const fillC = document.querySelector("#fillC").value || "#00e0ff";
        style = {
          color: strokeC,
          weight: strokeW,
          fillOpacity: fillA,
          fillColor: fillC,
        };

        map.removeControl(drawControl);
        drawControl = buildDraw(style);
        map.addControl(drawControl);

        drawnItems.eachLayer((l) => {
          if (l.setStyle) l.setStyle(style);
        });
      };

      // --- EXPORT: poligon saja (transparan) ---
      document.getElementById("export").onclick = () => {
        if (drawnItems.getLayers().length === 0) {
          alert("Belum ada poligon untuk diekspor.");
          return;
        }

        const nameInput = (
          document.getElementById("filename").value || ""
        ).trim();
        const filename = nameInput
          ? nameInput.replace(/\.(png|jpe?g|webp)$/i, "")
          : "polygons";

        const out = document.createElement("canvas");
        out.width = IMG_W;
        out.height = IMG_H;
        const ctx = out.getContext("2d");
        ctx.clearRect(0, 0, IMG_W, IMG_H); // transparan

        drawnItems.eachLayer((layer) => {
          // dukung Polygon & Rectangle (keduanya turunan L.Polygon)
          if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
            drawPolygon(ctx, layer, style);
          }
        });

        const a = document.createElement("a");
        a.download = `${filename}.png`;
        a.href = out.toDataURL("image/png");
        a.click();
      };

      // --- Helpers ---
      function drawPolygon(ctx, layer, sty) {
        const latlngs = layer.getLatLngs();
        const polygons = normalizePolygons(latlngs); // => Array< Array< Array<[x,y]> > >
        // Struktur output: [polygon][ring][point [x,y]]
        ctx.save();
        ctx.lineWidth = sty.weight;
        ctx.strokeStyle = sty.color;
        ctx.fillStyle = hexToRgba(sty.fillColor || sty.color, sty.fillOpacity);

        polygons.forEach((rings) => {
          ctx.beginPath();
          rings.forEach((ring) => {
            for (let i = 0; i < ring.length; i++) {
              const x = ring[i][0];
              const y = ring[i][1];
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
          });
          // evenodd agar lubang (holes) benar
          if (ctx.fill) ctx.fill("evenodd");
          ctx.stroke();
        });

        ctx.restore();
      }

      // NORMALISASI YANG BENAR:
      // - Jika level terendah adalah LatLng => map ke [lng, -lat]
      // - Tangani 1-level (ring), 2-level (polygon: [ring, hole...]), 3-level (multi-polygon)
      function normalizePolygons(latlngs) {
        if (!Array.isArray(latlngs) || latlngs.length === 0) return [];

        const isLatLng = (v) =>
          v && typeof v.lat === "number" && typeof v.lng === "number";

        // Case 1: ring langsung: LatLng[]
        if (isLatLng(latlngs[0])) {
          return [[latlngs.map((ll) => [ll.lng, -ll.lat])]];
        }

        // Case 2: polygon: LatLng[][]  (ring, holes...)
        if (
          Array.isArray(latlngs[0]) &&
          latlngs[0].length &&
          isLatLng(latlngs[0][0])
        ) {
          return [latlngs.map((ring) => ring.map((ll) => [ll.lng, -ll.lat]))];
        }

        // Case 3: multi-polygon: LatLng[][][]
        if (
          Array.isArray(latlngs[0]) &&
          Array.isArray(latlngs[0][0]) &&
          latlngs[0][0].length &&
          isLatLng(latlngs[0][0][0])
        ) {
          return latlngs.map((poly) =>
            poly.map((ring) => ring.map((ll) => [ll.lng, -ll.lat]))
          );
        }

        // Fallback defensif
        return [];
      }

      function hexToRgba(hex, a) {
        let m = (hex || "#00e0ff").replace("#", "");
        if (m.length === 3)
          m = m
            .split("")
            .map((c) => c + c)
            .join("");
        const int = parseInt(m, 16);
        const r = (int >> 16) & 255,
          g = (int >> 8) & 255,
          b = int & 255;
        return `rgba(${r},${g},${b},${a})`;
      }
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

      // Hindari klik toolbar menembus peta
      L.DomEvent.disableClickPropagation(document.getElementById("ui"));
    </script>
  </body>
</html>
